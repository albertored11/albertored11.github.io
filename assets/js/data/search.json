[ { "title": "Managing external display configuration with ddcutil", "url": "/posts/managing-external-display-configuration-with-ddcutil/", "categories": "Linux, Power management", "tags": "linux, bash, script, keyboard, display, ddcutil, sxhkd", "date": "2022-11-27 13:47:00 +0100", "snippet": "Almost every laptop keyboard include two function keys: one to decrease thebrightness of the screen and other to increase it.In most Linux desktop environments, those two keys work out-of-the-box for thelaptop display, but… what about external displays?Recently I got a new keyboard, and I was surprised to see those brightness keys.Since I’m using it for my desktop PC, at first I thought they would be uselessand I assigned them to other actions.However, a few days ago, I learnt about the existence ofDDC/CI, a CommonInterface standard that allows the computer to send commands to the display andto receive data from it over I2C, aserial communication bus.Those communication can be done in Linux thanks to the i2c-dev kernelmodule and, with a command line utility likeddcutil, it is as easy as issuing some commands inour shell.We’re going to learn how to install and configure ddcutil and to use it tocontrol the brightness of an indefinite number of external displays and toturn them off easily.Of course, displays must be compatible with the aforementioned standards. Butdon’t worry, most modern ones are!Installing and configuring ddcutilInstallationddcutil is available as a package in most distributions.For example, for Arch Linux:$ sudo pacman -S ddcutilConfigurationThen,some additional configuration steps are necessary.Load i2c-dev modulei2c-dev kernel module is required by ddcutil.Check if it is already available (e.g. if it is built into the kernel):$ lsmod | grep -F i2c_devIf not, it must be loaded explicitly:$ sudo bash -c &#39;echo i2c-dev &amp;gt; i2c-dev.conf&#39;A reboot is needed afterwards.Give permissions to I2C devicesOn some distributions, including Debian, Ubuntu and Arch Linux, all I2C devicesare assigned to the group i2c. This is done by the i2c-tools package,which is a dependency of ddcutil.In order for your user to have access to the devices, it must be added to thatgroup:$ sudo usermod $USER -aG i2cControlling brightnessDetect displaysFirst of all, run the following command to detect available displays:$ ddcutil detectYou will get an output like this:Display 1 I2C bus: /dev/i2c-1 DRM connector: card0-HDMI-A-2(ommited output)Display 2 I2C bus: /dev/i2c-4 DRM connector: card0-DP-1(ommited output)With that output, you can run commands that apply to the first display using theoption --display 1 or --bus 1 (because it uses the bus /dev/i2c-1), or tothe second display with --display 2 or --bus 4.Get/set brightnessDisplays have some settings coded into what is called VCP features. Their namesand their values can be queried using the getvcp command.Take a look at all of them for one display:$ ddcutil getvcp ALL --bus 1You will get the code and the value for each one. This is the one forbrightness:VCP code 0x10 (Brightness ): current value = 100, max value = 100That means brightness feature has code 10, its current value is 100 and itsmaximum value is 100.That value can be set using the setvcp command:$ ddcutil setvcp 10 50 --bus 1That command would set brightness to 50 % for display with bus number 1.It also works with deltas:$ ddcutil setvcp 10 + 5 --bus 1$ ddcutil setvcp 10 - 5 --bus 1Those commands would respectively increase and decrease brightness by 5 %.Set brightness in all displays at onceddcutil doesn’t have an option to run a command for multiple displays. Aworkaround is using xargs. Assuming you have 2 displays with bus numbers 1 and4 and you want to increase brightness by 5 % for both of them:$ echo &quot;1 4&quot; | xargs -n1 -P2 sh -c &#39;ddcutil setvcp 10 + 5 --bus $1&#39; shwould do the trick.Important: use bus numbers rather than display numbers to referencedisplays. Otherwise, parallel commands won’t work.Turning displays offAnother interesting VCP feature is Power mode, which can be set to turn onand off the display. In my case, it only works to turn them off, but I guess itdepends on the display model.The VCP code for this feature is d6:$ ddcutil getvcp d6 --bus 1VCP code 0xd6 (Power mode ): DPM: On, DPMS: Off (sl=0x01)In order to turn off the display, the value has to be set to 5 and, to turnit on, it has to be set to 1, so$ ddcutil setvcp d6 5 --bus 1would turn off display with bus number 1.Control brightness using the keyboardLet’s get to the interesting part: doing all this conveniently using thekeyboard!Shell scriptThe following script can be used to easily set brightness in all displays to afixed value or to increase or decrease it, or to turn them off.#!/usr/bin/env bashprogname=&quot;$(basename &quot;$0&quot;)&quot;usage() { echo &quot;usage: $progname &amp;lt;up/down/set/off&amp;gt; [brightness %]&quot; &amp;gt;&amp;amp;2 exit 1}[[ &quot;$#&quot; -eq 1 || &quot;$#&quot; -eq 2 ]] || usage# Exit if an instance of the script is already running to avoid errors# It has to be somewhere in $PATH for this to workn_px=$(pgrep -f &quot;^bash $(which $progname)&quot; | wc -l)[[ $n_px -gt 2 ]] &amp;amp;&amp;amp; exit 1# Get bus number for all displays and number of displaysdisplays=$(ddcutil detect --terse | grep -F &quot;I2C bus:&quot; | awk -F &#39;-&#39; &#39;{print $2}&#39;)n_displays=$(echo $displays | wc -w)case &quot;$1&quot; in up) b=&quot;+\\ $2&quot; ;; down) b=&quot;-\\ $2&quot; ;; set) b=&quot;$2&quot; ;; off) # Turn off all displays echo $displays | xargs -n1 -P$n_displays sh -c &#39;ddcutil setvcp d6 5 --bus $1&#39; sh exit 0 ;; *) usage ;;esacconf=$(for m in $displays; do echo $m $b; done)echo $conf | xargs -n2 -P$n_displays sh -c &#39;ddcutil setvcp 10 $2 --bus $1&#39; shYou can find this scriptin my dotfiles,which includes an extra feature to use xob.Save this script somewhere in your $PATH. The following commands can be used,assuming we named it brightctl: up/down: increase/decrease brightness by x % (e.g. brightctl up 5). set: set brightness to x % (e.g. brightctl set 80). off: turn displays off (e.g. brightctl off).KeybindingsNow, we can assign calls to the script to the keyboard using, for example,sxhkd.You can add this to your sxhkdrc:# brightness up/downXF86MonBrightness{Up,Down} bright-notif {up,down} 5# custom brightnessctrl + XF86MonBrightness{Up,Down} bright-notif set {100,30}This way, brightness can be increased/decreased by 5 % using the brightnesskeys and, with the Control modifier, it can be set to 30 % or 100 %.You will notice that running one of these commands is much slower than whencontrolling the brightness of a native display.Turning displays off convenientlyShell scriptWe can use the turning off displays feature at our convenience: for example,after before locking the screen or just before suspending the system.I use a script to lock the screen with two options: turning off displays andsuspending the system.#!/usr/bin/env bashusage() {printf &quot;%s&quot; &quot;\\usage: $(basename &quot;$0&quot;) [options]Options: -h, --help show this help message and exit. -o, --off turn all displays off. -s, --suspend run systemctl suspend afterwards.&quot;exit 1}get_args() { TEMP=$(getopt \\ -l &#39;help,off,suspend&#39; \\ -o &#39;hos&#39; \\ -n &quot;$(basename &quot;$0&quot;)&quot; \\ -- &quot;$@&quot;) || exit 1 eval set -- &quot;$TEMP&quot; unset TEMP while true; do case &quot;$1&quot; in &#39;-h&#39; | &#39;--help&#39;) usage ;; &#39;-o&#39; | &#39;--off&#39;) off=1 shift continue ;; &#39;-s&#39; | &#39;--suspend&#39;) susp=1 shift continue ;; &#39;--&#39;) shift break ;; *) printf &quot;error\\n&quot; &amp;gt;&amp;amp;2 exit 1 ;; esac done}main() { get_args &quot;$@&quot; [[ -z &quot;$(pgrep -f ^i3lock)&quot; ]] || exit 1 # Comment if not using dunst killall -SIGUSR1 dunst [[ &quot;$off&quot; ]] &amp;amp;&amp;amp; bright-notif off # Use your favorite i3lock options i3lock [options] &amp;amp; if [[ &quot;$susp&quot; ]]; then sleep 0.5 systemctl suspend fi wait # Comment if not using dunst killall -SIGUSR2 dunst return 0}main &quot;$@&quot;You can also find this scriptin my dotfiles.When using --off option, the displays are turned off before locking thescreen. When using --suspend option, the system is suspended after lockingthe screen.KeybindingsYou can add this to your sxhkdrc:# lock screensuper + {_,alt + }l lock-screen{_, --off}# suspendsuper + shift + s lock-screen --off --suspendSo, this way with Super + L, the screen is locked with Super + Alt + L, the displays turn off and the screen is locked with Super + Shift + S, the displays turn off, the screen is locked and thesystem is suspended" }, { "title": "SSD + HDD storage setup in a Linux desktop with bind mount", "url": "/posts/ssd-hdd-storage-setup-in-a-linux-desktop-with-bind-mount/", "categories": "Linux, System administration", "tags": "linux, storage, hdd, sdd, fstab, bind, mount", "date": "2021-10-29 18:36:00 +0200", "snippet": "Hi everyone! Today I’m going to share with you how I have set up my storage in my desktop PC using a 250 GB SSD and a 2 TB HDD.BackgroundBack in august 2020, I built my own desktop PC with the help of a friend, and the storage I decided to use was: a Samsung MZ-V7S250BW 250 GB NVMe M.2 SSD and a Seagate ST2000DM008 Barracuda 2TB HDDAnd my choice for the main OS was Linux (specifically, Arch Linux).First idea: EFI and root in SSD, home in HDDBefore building my PC, I had been thinking about the partition layout I was going to use. After doing some research on the internet, my initial idea was to use the SSD for the EFI System Partition, mounted in /boot, and the root partition, mounted in /, and the HDD for a single partition mounted in /home.The idea was to store the system files, which usually need a fast access, in the fastest drive (and also the smaller and the most expensive), the SSD, and the user files, which are mostly less frequently accessed and which access speed is not critical, in the slowest drive (and also the biggest and the cheapest), the HDD.The filesystem I decided to use for the / and /home partitions was ext4, since it is simple and rock-solid. I’m curious about other filesystems like btrfs, which have really interesting features, but at the moment I’m sticking to ext4.So, when my friend and I finished building the PC, I did a first Arch Linux install with the layout I just described. However, when I booted up my machine after installing the graphical enviroment, I noticed the configuration didn’t load correctly. I assumed that was because the configuration files need a fast access just like the system files, and the user config files are stored in $HOME/.config, which was a subdirectory of the mountpoint of the HDD (/home).Second idea: EFI and root in SSD, HDD single partition mounted in home and symlink dirsThen, I did a second installation from scratch, using a different partition layout: just using the SSD like the previous time and no separate partition for /home. I would figure out later what to do with the HDD.The idea I came up with was mounting the HDD in a subdirectory under my $HOME directory called .hdd, and inside making directories for every standard XDG user directory I wanted to be stored in the HDD (Documents, Music, Pictures and Videos). The rest of the directories (Downloads, hidden directories such as .config, .cache, etc.) would be stored in the SSD. Then, I would symlink those directories in .hdd to $HOME/Documents, $HOME/Music, etc.At first it seemed like it was a good setup and worked as intended, but later I realized it wasn’t. Why? Mounting a device that could be used at a system level in a hidden user directory sounds dirty. Using the symlinked directories was a problem for certain things.Final idea: EFI and root in SSD, HDD single partition mounted in root and bind mount dirsBind mountI wasn’t satisfied with my previous setup, so I did a bit more research and heard about bind mount, which is basically mounting a subdirectory from a partition that is already mounted in another directory. This, unlike symlinks, doesn’t work at a filesystem level, so we’re not actually changing anything in our filesystems. Instead, we are showing the same directory in two different points.This means that we can mount a partition somewhere in our root filesystem and then selectively remount directories in it in another part of our root filesystem or even in another filesystem so they are available in both locations.For example, let’s say we have a directory under /home/myuser/Pictures/MyDownloadedPics/Wallpapers that we want to be available at /home/otheruser/MyWallpapers as well. We can bind mount the first directory in the latter… and that’s it! We can access the same directory using two different locations, and any modification on one directory is immediately effective on the other one, as they are showing the same data.SetupSo the final idea for my setup was mounting the HDD in /mnt/home, creating a directory for my user, and inside it, the XDG user directories I wanted in the HDD (Documents, Music, Pictures and Videos). Finally, I would bind mount those directories in $HOME/Documents, $HOME/Music, etc.That way, I would have everything stored in the SDD but the user directories which are usually used to store large files (or a large number of files) that doesn’t require fast access (pictures, videos, music, etc.).I started using this setup several months ago and I think it is just the best solution. Of course, this is totally subjective and there are probably other and better ways to do this, so feel free to let me know if that is the case.TutorialSo… how can we achieve this setup?I’m going to explain it step by step, covering both the cases of a new and an existing Linux-based installation.I’m assuming the device file for the SSD is /dev/nvme0n1 and the device file for the HDD is /dev/sda, which is my case and may be yours, but it also may not be, so replace them if necessary.New installationCreate and format partitionsIf we are in the case of a new installation, the first thing we have to do when it is required during the installation process is to create the partitions and the filesystems.We are using the cfdisk tool with this purpose. If your distro uses a graphical installer, create the described partition layout using the appropriate tool.First, we’re going to proceed with the SSD:# cfdisk /dev/nvme0n1Create a GPT partition table.Create a new partition for the EFI System Partition. A size of 512M should be more than enough. Set the partition type to EFI System.Create a new partition for the root filesystem. Use the remaining size.Write changes and quit.Format partitions accordingly (FAT32 for EFI System Partition as required, and ext4 for the root partition for simplicity):# mkfs.ext4 /dev/nvme0n1p2# mkfs.fat -F32 /dev/nvme0n1p1Then, with the HDD:# cfdisk /dev/sdaCreate a GPT partition table.Create a new partition for /mnt/home. Use the total size of the disk.Write changes and quit.Format the newly created partition:# mkfs.ext4 /dev/sda1Mount partitionsFirst, mount the root partition:# mount /dev/nvme0n1p2 /mntCreate the mountpoints for the other partitions:# mkdir -p /mnt/boot /mnt/mnt/homeand mount them:# mount /dev/nvme0n1p1 /mnt/boot# mount /dev/sda1 /mnt/mnt/homePrepare bind mountpointsWhen the installation process is finished and we have successfully booted up our system and created and logged in as an unprivileged user, we can move on to the exciting part: setting up bind mount!First, let’s create the standard XDG user directories (you may will the xdg-user-dirs package):$ xdg-user-dirs-updateThen, create the directories we’re going to bind mount to our $HOME in our HDD. My personal choice is Documents, Music, Pictures and Videos, but feel free to make yours as needed. Think of which directories are you going to store large files (or a large number of files) that don’t need fast access in.First, create a directory for our user in /mnt/home and change the ownership so the directory belongs to it:$ cd /mnt/home$ sudo mkdir -p myuser$ sudo chown -R myuser:myuser myuserand after that create the directories themselves:$ cd myuser$ mkdir -p Documents Music Pictures VideosDefine bind mountpointsFinally, edit the /etc/fstab file, which describes how filesystems have to be mounted. Add the following lines at the end (modify them as needed if you’re using different directories):# /mnt/home/myuser/Documents/mnt/home/myuser/Documents /home/myuser/Documents none rw,bind 0 0# /mnt/home/myuser/Music/mnt/home/myuser/Music /home/myuser/Music none rw,bind 0 0# /mnt/home/myuser/Pictures/mnt/home/myuser/Pictures /home/myuser/Pictures none rw,bind 0 0# /mnt/home/myuser/Videos/mnt/home/myuser/Videos /home/myuser/Videos none rw,bind 0 0Those lines are telling our system to bind mount /mnt/home/myuser/Documents to /home/myuser/Documents, /mnt/home/myuser/Music to /home/myuser/Music and so on.Test the setup:$ sudo mount -aand try creating a file in one of the bind mounted directories. For example, if we create a file called test in /home/myuser/Documents, it should appear in /mnt/home/myuser/Documents as well.If it works fine, we’re done! On the next reboots, the bind mount will happen automatically.And that’s it! We will have everything stored in our SSD, excepting the files saved to our Documents, Music, Pictures and Videos user directories.Existing installationBut what if we want to use this setup in an existing Linux installation? The steps to follow depend on the situation: if you are already using your drive for your home partition, it will be a little more tricky.Extra drive unused or not mounted in the home directoryLet’s start with the easiest case: you just installed the new drive or you just were not using it, or it was mounted in your filesystem, but not in /home.I’m assuming the drive is already partitioned and formatted with a single ext4 partition which device file is /dev/sda1.First of all, if the partition is mounted, unmount it:$ sudo umount /dev/sda1Create the mountpoint for the partition:$ sudo mkdir -p /mnt/homeand append a couple of lines to /etc/fstab file to define the mount:$ sudo bash -c &#39;echo &quot;# /dev/sda1&quot; &amp;gt;&amp;gt; /etc/fstab&#39;$ sudo bash -c &#39;echo -e &quot;UUID=$(blkid -s UUID -o value /dev/sda1)\\t/mnt/home\\text4\\t\\trw,relatime\\t0 2&quot; &amp;gt;&amp;gt; /etc/fstab&#39;$ sudo bash -c &#39;echo &amp;gt;&amp;gt; /etc/fstab&#39;If the partition used to be mounted in a different path, remove those lines, too.Check /etc/fstab file manually to verify everything is correct and well-formatted and test the configuration:$ sudo mount -aIf it works properly, now follow the guide for a new installation starting from here but, instead of creating directories in /mnt/home/myuser, move them from /home/myuser and create empty directories in the latter:skip$ cd myuser$ mkdir -p Documents Music Pictures Videosand instead do$ mv /home/myuser/{Documents,Music,Pictures,Videos} /mnt/home/myuser$ mkdir -p /home/myuser/{Documents,Music,Pictures,Videos}Extra drive used for home partitionAnother case would be that you are already using that extra drive and having it mounted in /home. How can we do the migration then?First of all, log out as your user and log in as root in a tty (if you are using a desktop manager, hit Alt + F2 or Ctrl + Alt + F2 to switch to tty2). We’re doing this because regular users have their home directory under /home, which we are about to remount in a different path, while root user has its home under /root, so that won’t cause any problem.I’m assuming the corresponding device for the former home partition is /dev/sda1.Unmount the home partition:# umount /dev/sda1Create the mountpoint for the partition:# mkdir -p /mnt/homeand edit /etc/fstab accordingly, replacing /home with /mnt/home, which is the new mountpoint for our partition:# sed -i &#39;s/home/mnt\\/home/g&#39; /etc/fstabCheck /etc/fstab file manually to verify everything is correct and test the configuration:# mount -aIf it works properly, now recreate the home directory for your user in /home (and for every other regular user in your system):# mkdir -p /home/myuser# chown myuser:myuser /home/myuserThen, we are going to move everything there except the directories you want to keep in your extra drive. First, enable a couple of shell options for glob matching:# shopt -s extglob# shopt -s dotglobThose will let us match everything except certain files or directories, and match hidden files too when using * wildcard.Then move everything inside our home directory except, for example, Documents, Music, Pictures and Videos, if those are the directories we want to keep in the extra drive:# mv /mnt/home/myuser/!(Documents|Music|Pictures|Videos) /home/myuserMake empty directories under our home directory for those that are going to stay in the extra drive so we can bind mount them and make them belong to your user:# mkdir -p /home/myuser/{Documents,Music,Pictures,Videos}# chown myuser:myuser /home/myuser/{Documents,Music,Pictures,Videos}Now, reboot your system and log in as your regular user and follow the guide for a new installation starting from here.ConclusionAnd that’s all! I hope you find this setup useful and, as always, reach me out at albertomost@gmail.com if you have any questions, suggestions, etc." }, { "title": "bsptab — tabs in bspwm with tabbed!", "url": "/posts/bsptab-tabs-in-bspwm-with-tabbed/", "categories": "Linux, Window Management", "tags": "linux, xorg, tabs, bspwm, tabbed, bash, script", "date": "2021-09-02 14:39:00 +0200", "snippet": "Today, I’m going to show you a project I’ve been working on the last days.It is now more than two years that I came back to Linux. I tried Manjarofirst, then moved to Arch. And at first I used KDE Plasma as my desktopenvironment, but I’ve always been curious about using a standalone tilingwindow manager, so a few months ago I took that step and tried bspwm and i3.Now, bspwm has become my favorite WM. I really like its architecture (binaryspace partitioning-based algorithm, dedicated socket…), its simplicity (it’sjust a WM, nothing else), its scriptability (bspc provides a lot of usefulcommands, and the subscribe command is really helpful)…However, there is a feature that I liked from i3 that is missing in bspwm:tabbed layouts, which is a really useful feature for many workflows.A few months ago I knew about tabbed,a tool from suckless to create tabbed containers in Xenvironments, and saw this script whichhelps to integrate it into any WM.Now, since lately I’ve been interested in bash scripting, I decided torewrite that script and add more features and workarounds to bugs, and theresult is quite usable!Features Adds tabbed layouts to bspwm. Each tabbed container handles multiple windows, but not any more tabbedcontainers. Automatically attach new windows to tabbed containers.bsptab in action! tabc create commandOpen a Chromium window, create a tabbed container using a keyboard shortcut andopen new windows as tabs. tabc attach commandAttach window (right) to a tabbed container (left) using a keyboard shortcut. tabc detach commandDetach a couple of windows from a tabbed container and then combine them tocreate a new container(again, using keyboard shortcuts). tabc autoattach commandToggle autoattach function using a keyboard shortcut: first, it is enabled, sonew windows appear as tabs; then, it is disabled, so new windows are placed asusual. tabbed-auto scriptOpen an instance of pcmanfm-qt, and a tabbed container is automatically created,so every new window opened is added as a tab.Find out moreI hope you like my project! :)If you find it interesting, feel free to try it and please report any bugsyou find, and let me know about any new features you’d like to see.Also, I am not a bash expert at all, so if you think any part of the code shouldbe rewritten in a better way, let me know as well!I createda postin the r/bspwm subreddit, so, if you prefer,leave a comment there." }, { "title": "Automatically cleaning pacman and yay cache in Arch Linux", "url": "/posts/automatically-cleaning-pacman-and-yay-cache-in-arch-linux/", "categories": "Linux, System administration", "tags": "arch linux, pacman, yay, bash, cache, script", "date": "2021-03-29 19:16:00 +0200", "snippet": "Let’s talk about something interesting for Arch Linux(-based) distros: automating package cache cleaning.Cleaning pacman cachepacman is the official package manager for Arch. When using it to install a package from official repositories, it gets donwloaded, stored in our system (specifically, in /var/cache/pacman/pkg), and finally it is installed and the package file stays there, in case we need to reinstall it in the future (for example, if we have uninstalled it and then we want to install it again), or in case we install a newer version, it doesn’t work as expected and we want to downgrade.However, the package cache is never cleaned automatically and, as we install and upgrade packages, it grows up in size. We could wait until our / is full and then cleaning it… or cleaning it automatically, keeping the files that can be useful.pacman features an operation for cleaning cache of uninstalled packages, pacman -Sc, and for cleaning cache for every package, pacman -Scc. However, it could be interesting to clean it keeping the two latest versions of each package (the installed one and the previous one), so we always have a previous version for every package, but not every of them, in case we have to downgrade. We can achieve this using paccache, a script from pacman-contrib package.Running paccache -rk2, we clean the package cache keeping just the two latest versions of each package. Furthermore, we can use -u option for cleaning just the cache of uninstalled packages so if, for example, we want to keep the two latest versions for installed packages and just the latest for uninstalled packages (in case we want to reinstall them in the future, for example for make dependencies of AUR packages), we could run:$ paccache -rk2 &amp;amp;&amp;amp; paccache -ruk1Cleaning yay cacheyay is an AUR helper and a pacman wrapper, a program that uses its features and some additional ones; in this case, installing packages from AUR, the community-driven repository for Arch users.AUR does not store binary packages, but scripts called PKGBUILDs that download source or binary files from an external source and make the pacman package, and some extra files. yay does this automatically, but in the cache (located in ~/.cache/yay) it stores not just the created package, but also original source or binary files and files generated in the process. We have to keep in mind that each package has its own cache directory.yay has an operation -Sc similar to pacman’s but, again, paccache seems more interesting. This script has an option, -c for specifying cache location, so we can write the cache directory for every package installed with yay. For example, if we want to clean yay cache keeping the two latest versions for installed packages and nothing for uninstalled packages, we could run:$ paccache -rk2 -c ~/.cache/yay/*/ &amp;amp;&amp;amp; paccache -ruk0 ~/.cache/yay/*/However, this command only removes pacman packages, but not other files. It could be interesting to keep source or binary files from installed version (in case we upgrade the package and it uses the same ones as the previous version) and the files from the git repository of the AUR package (otherwise, yay will throw an error when we try to upgrade the package), but not the rest of the source or binary files nor the ones generated during the creation of the package.Bash script for cleaning both cachesTip: enable batchinstall option for yay to avoid extra downloads when upgrading AUR packages.First of all, install pacman-contrib package if you haven’t done it yet:$ sudo pacman -S pacman-contribI’ve written a bash script for easily cleaning both pacman and yay caches, based on these ones I found on GitHub Gist, created by luukvbaal.##!/usr/bin/env bash## Assuming yay is run by user with UID 1000admin=&quot;$(id -nu 1000)&quot;cachedir=&quot;/home/$admin/.cache/yay&quot;removed=&quot;$(comm -23 &amp;lt;(basename -a $(find $cachedir -mindepth 1 -maxdepth 1 -type d) | sort) &amp;lt;(pacman -Qqm) | xargs -r printf &quot;$cachedir/%s\\n&quot;)&quot;## Remove yay cache for foreign packages that are not installed anymorerm -rf $removedpkgcache=&quot;$(find $cachedir -mindepth 1 -maxdepth 1 -type d | xargs -r printf &quot;-c %s\\n&quot;)&quot;for pkgdir in &quot;$cachedir&quot;/*/; do pkgname=$(basename &quot;$pkgdir&quot;) ## Remove untracked files (e. g. source/build files) excepting package files and main source files for installed version if non-git package if [[ ! &quot;$pkgname&quot; =~ ^.*-git$ ]]; then pkgver=&quot;$(pacman -Q $pkgname | cut -d &#39; &#39; -f2 | cut -d &#39;-&#39; -f1 | cut -d &#39;:&#39; -f2)&quot; cd &quot;$pkgdir&quot; rm -f $(git ls-files --others | grep -v -e &#39;^.*\\.pkg\\.tar.*$&#39; -e &#39;^.*/$&#39; -e &quot;^.*$pkgver.*$&quot; | xargs -r printf &quot;$pkgdir/%s\\n&quot;) fi rm -rf &quot;$pkgdir&quot;/src/done## Remove everything for uninstalled foreign packages, keep latest version for uninstalled native packages, keep two latest versions for installed packages/usr/bin/paccache -qruk0 $pkgcache/usr/bin/paccache -qruk1/usr/bin/paccache -qrk2 -c /var/cache/pacman/pkg $pkgcacheIt cleans both caches using paccache, keeping the two latest versions for installed packages, the latest version for uninstalled packages from official repositories and nothing for uninstalled packages from AUR, it removes the directories of uninstalled packages from AUR located in yay cache and extra files from the directories of insatlled packages, excepting the files tracked by git, the pacman packages and the source or binary files of the installed version.We can save the script, for example, in ~/.local/bin, or whichever directory you prefer from your $PATH, so we can run it just typing yaycache.Pacman hook for automating cache cleaningThis script can be useful for cleaning pacman and yay caches, but we haven’t reached the automation part yet.In order to implement automation, I’ve written a pacman hook, a file that runs a command after installing, removing or upgrading certain packages.In this case, the script is run after removing or upgrading any package. It does not run after installing a package, because yay installs make dependencies when needed and running the script would remove necessary files and therefore installation would fail.[Trigger]Operation = UpgradeOperation = RemoveType = PackageTarget = *[Action]Description = Cleaning pacman and yay cache...When = PostTransactionExec = /home/herbort/.local/bin/yaycacheDepends = pacman-contribDon’t forget to change Exec path so it points to the right path where you saved the script.We have to save the hook file in /usr/share/libalpm/hooks, so it gets triggered when using pacman.And that’s all…I hope this way of cleaning pacman and yay caches is useful for you and, of course, I appreciate any suggestions and comments.You can find both files in this gist!" } ]
